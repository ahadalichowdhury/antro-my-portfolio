import { c as createAstro, a as createComponent, f as renderComponent, r as renderTemplate, u as unescapeHTML, e as addAttribute, m as maybeRenderHead } from '../../chunks/astro/server_xhRB2sXi.mjs';
import 'kleur/colors';
import { $ as $$BaseLayout } from '../../chunks/BaseLayout_BK6VYfps.mjs';
import { a as $$Footer, $ as $$Header } from '../../chunks/Footer_BgMcPR-r.mjs';
import { g as getPostsCollection } from '../../chunks/models_CquBuAEI.mjs';
export { renderers } from '../../renderers.mjs';

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const $$Astro = createAstro("https://example.com");
const $$slug = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$slug;
  const { slug } = Astro2.params;
  if (!slug) {
    return Astro2.redirect("/blog", 404);
  }
  const postsCollection = await getPostsCollection();
  let post = await postsCollection.findOne({ slug, published: true });
  if (!post) {
    try {
      const { ObjectId } = await import('mongodb');
      if (ObjectId.isValid(slug)) {
        post = await postsCollection.findOne({ _id: new ObjectId(slug) });
        if (post) {
          post = {
            ...post,
            description: post.description || post.excerpt || "",
            createdAt: post.createdAt || post.date || /* @__PURE__ */ new Date(),
            published: post.published !== void 0 ? post.published : true,
            slug: post.slug || post._id?.toString() || ""
          };
        }
      }
    } catch (e) {
    }
  }
  if (!post) {
    return Astro2.redirect("/blog", 404);
  }
  const ogImage = post.coverImage || "/resource/emojis.com panda-bear-full-body-scratching.png";
  return renderTemplate`${renderComponent($$result, "BaseLayout", $$BaseLayout, { "title": `${post.title} - S. M. Ahad Ali Chowdhury`, "description": post.description, "ogImage": ogImage, "ogType": "article", "canonicalUrl": `/blog/${post.slug}` }, { "default": async ($$result2) => renderTemplate(_a || (_a = __template([" ", '<div class="container"> ', ' <!-- Blog Post --> <article class="blog-post"', '> <header class="post-header"> <h1>', "</h1> ", ' <p class="post-date"> ', ' </p> <div style="display: flex; gap: 16px; margin-top: 8px; font-size: 14px; color: var(--text-secondary);"> <span>\u{1F441}\uFE0F ', " ", "</span> ", " </div> ", ' </header> <div class="post-content">', '</div> <div class="post-footer"> <a href="/blog" class="back-link">\u2190 Back to all posts</a> </div> </article> ', " </div> <script>\n    // Track post view and reading time\n    (function() {\n      let trackingInitialized = false;\n      \n      function initTracking() {\n        // Prevent double initialization\n        if (trackingInitialized) {\n          console.log('[Tracking] Already initialized, skipping...');\n          return;\n        }\n        \n        // Wait a bit for DOM to be fully ready (especially for SPA navigation)\n        setTimeout(() => {\n          console.log('[Tracking] Initializing tracking...');\n          \n          // Get postId from data attribute\n          const article = document.querySelector('.blog-post');\n          const postId = article ? article.getAttribute('data-post-id') : null;\n          \n          console.log('[Tracking] Article element:', article);\n          console.log('[Tracking] Post ID:', postId);\n          \n          if (!postId) {\n            console.error('[Tracking] Post ID not found, retrying in 500ms...');\n            // Retry once after a delay (for SPA navigation)\n            setTimeout(() => {\n              const retryArticle = document.querySelector('.blog-post');\n              const retryPostId = retryArticle ? retryArticle.getAttribute('data-post-id') : null;\n              if (retryPostId) {\n                console.log('[Tracking] Post ID found on retry:', retryPostId);\n                startTracking(retryPostId);\n              } else {\n                console.error('[Tracking] Post ID still not found after retry');\n              }\n            }, 500);\n            return;\n          }\n          \n          startTracking(postId);\n        }, 100);\n      }\n      \n      function startTracking(postId) {\n        if (trackingInitialized) return;\n        trackingInitialized = true;\n        \n        console.log('[Tracking] Starting tracking for postId:', postId);\n        \n        let startTime = Date.now();\n        let readingTime = 0;\n        let isActive = true;\n        let lastActiveTime = Date.now();\n        const INACTIVE_THRESHOLD = 30000; // 30 seconds of inactivity\n        const MIN_READING_TIME = 5; // Minimum 5 seconds to count as a read\n        let viewTracked = false; // Prevent duplicate view tracking\n\n        // Track initial view (only once)\n        function trackView() {\n          if (viewTracked) {\n            console.log('[Tracking] View already tracked, skipping...');\n            return;\n          }\n          \n          console.log('[Tracking] Tracking view for postId:', postId);\n          viewTracked = true;\n          \n          fetch('/api/track-view', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ postId }),\n          })\n          .then(response => {\n            if (!response.ok) {\n              throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            console.log('[Tracking] View tracked, response status:', response.status);\n            return response.json();\n          })\n          .then(data => {\n            console.log('[Tracking] View tracking response:', data);\n            if (!data.success) {\n              console.warn('[Tracking] View tracking returned non-success:', data);\n            }\n          })\n          .catch(err => {\n            console.error('[Tracking] Failed to track view:', err);\n            viewTracked = false; // Allow retry on error\n          });\n        }\n\n      // Track reading time when user leaves\n      function trackReadingTime() {\n        if (!isActive) {\n          console.log('[Tracking] User inactive, skipping reading time tracking');\n          return;\n        }\n        \n        const now = Date.now();\n        const activeTime = (now - lastActiveTime) / 1000; // Convert to seconds\n        \n        if (activeTime >= MIN_READING_TIME) {\n          readingTime = Math.floor(activeTime);\n          console.log('[Tracking] Tracking reading time:', readingTime, 'seconds');\n          \n          // Use sendBeacon for more reliable tracking on page unload\n          const data = JSON.stringify({ postId, readingTime });\n          if (navigator.sendBeacon) {\n            const blob = new Blob([data], { type: 'application/json' });\n            const sent = navigator.sendBeacon('/api/track-view', blob);\n            console.log('[Tracking] Reading time sent via sendBeacon:', sent);\n          } else {\n            // Fallback to fetch\n            fetch('/api/track-view', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: data,\n              keepalive: true, // Keep request alive even after page unload\n            })\n            .then(response => {\n              console.log('[Tracking] Reading time tracked, response status:', response.status);\n              return response.json();\n            })\n            .then(data => console.log('[Tracking] Reading time tracking response:', data))\n            .catch(err => console.error('[Tracking] Failed to track reading time:', err));\n          }\n        } else {\n          console.log('[Tracking] Reading time too short:', activeTime, 'seconds, not tracking');\n        }\n      }\n\n      // Track user activity\n      function updateActivity() {\n        if (!isActive) {\n          isActive = true;\n          lastActiveTime = Date.now();\n        } else {\n          lastActiveTime = Date.now();\n        }\n      }\n\n      // Check for inactivity\n      function checkInactivity() {\n        const now = Date.now();\n        if (isActive && (now - lastActiveTime) > INACTIVE_THRESHOLD) {\n          isActive = false;\n        }\n      }\n\n      // Event listeners\n      ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event => {\n        document.addEventListener(event, updateActivity, { passive: true });\n      });\n\n      // Track initial view\n      trackView();\n\n      // Check inactivity every 10 seconds\n      setInterval(checkInactivity, 10000);\n\n      // Track reading time when user leaves\n      window.addEventListener('beforeunload', trackReadingTime);\n      window.addEventListener('pagehide', trackReadingTime);\n\n      // Also track reading time periodically (every 30 seconds) for long reads\n      setInterval(() => {\n        if (isActive) {\n          const activeTime = (Date.now() - lastActiveTime) / 1000;\n          if (activeTime >= 30) {\n            readingTime = Math.floor(activeTime);\n            console.log('[Tracking] Periodic reading time tracking:', readingTime, 'seconds');\n            fetch('/api/track-view', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({ postId, readingTime }),\n            })\n            .then(response => {\n              if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n              }\n              console.log('[Tracking] Periodic reading time tracked, response status:', response.status);\n              return response.json();\n            })\n            .then(data => {\n              console.log('[Tracking] Periodic reading time response:', data);\n              if (data.success) {\n                lastActiveTime = Date.now(); // Reset to avoid double counting\n              }\n            })\n            .catch(err => console.error('[Tracking] Failed to track periodic reading time:', err));\n          }\n        }\n      }, 30000);\n      }\n      \n      // Initialize tracking\n      // For direct page loads, initialize immediately\n      // For SPA navigation, script.js will call initializeBlogTracking()\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', initTracking);\n      } else {\n        // Check if this is SPA navigation (script.js loaded)\n        setTimeout(() => {\n          if (typeof window !== 'undefined' && typeof initializeBlogTracking === 'function') {\n            // SPA navigation - let script.js handle it\n            console.log('[Tracking] SPA navigation detected, using script.js tracking');\n            // Reset flag so script.js can initialize\n            if (window.blogTrackingInitialized) {\n              window.blogTrackingInitialized = false;\n            }\n            initializeBlogTracking();\n          } else {\n            // Direct page load - use inline tracking\n            initTracking();\n          }\n        }, 100);\n      }\n    })();\n  <\/script> "], [" ", '<div class="container"> ', ' <!-- Blog Post --> <article class="blog-post"', '> <header class="post-header"> <h1>', "</h1> ", ' <p class="post-date"> ', ' </p> <div style="display: flex; gap: 16px; margin-top: 8px; font-size: 14px; color: var(--text-secondary);"> <span>\u{1F441}\uFE0F ', " ", "</span> ", " </div> ", ' </header> <div class="post-content">', '</div> <div class="post-footer"> <a href="/blog" class="back-link">\u2190 Back to all posts</a> </div> </article> ', " </div> <script>\n    // Track post view and reading time\n    (function() {\n      let trackingInitialized = false;\n      \n      function initTracking() {\n        // Prevent double initialization\n        if (trackingInitialized) {\n          console.log('[Tracking] Already initialized, skipping...');\n          return;\n        }\n        \n        // Wait a bit for DOM to be fully ready (especially for SPA navigation)\n        setTimeout(() => {\n          console.log('[Tracking] Initializing tracking...');\n          \n          // Get postId from data attribute\n          const article = document.querySelector('.blog-post');\n          const postId = article ? article.getAttribute('data-post-id') : null;\n          \n          console.log('[Tracking] Article element:', article);\n          console.log('[Tracking] Post ID:', postId);\n          \n          if (!postId) {\n            console.error('[Tracking] Post ID not found, retrying in 500ms...');\n            // Retry once after a delay (for SPA navigation)\n            setTimeout(() => {\n              const retryArticle = document.querySelector('.blog-post');\n              const retryPostId = retryArticle ? retryArticle.getAttribute('data-post-id') : null;\n              if (retryPostId) {\n                console.log('[Tracking] Post ID found on retry:', retryPostId);\n                startTracking(retryPostId);\n              } else {\n                console.error('[Tracking] Post ID still not found after retry');\n              }\n            }, 500);\n            return;\n          }\n          \n          startTracking(postId);\n        }, 100);\n      }\n      \n      function startTracking(postId) {\n        if (trackingInitialized) return;\n        trackingInitialized = true;\n        \n        console.log('[Tracking] Starting tracking for postId:', postId);\n        \n        let startTime = Date.now();\n        let readingTime = 0;\n        let isActive = true;\n        let lastActiveTime = Date.now();\n        const INACTIVE_THRESHOLD = 30000; // 30 seconds of inactivity\n        const MIN_READING_TIME = 5; // Minimum 5 seconds to count as a read\n        let viewTracked = false; // Prevent duplicate view tracking\n\n        // Track initial view (only once)\n        function trackView() {\n          if (viewTracked) {\n            console.log('[Tracking] View already tracked, skipping...');\n            return;\n          }\n          \n          console.log('[Tracking] Tracking view for postId:', postId);\n          viewTracked = true;\n          \n          fetch('/api/track-view', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ postId }),\n          })\n          .then(response => {\n            if (!response.ok) {\n              throw new Error(\\`HTTP error! status: \\${response.status}\\`);\n            }\n            console.log('[Tracking] View tracked, response status:', response.status);\n            return response.json();\n          })\n          .then(data => {\n            console.log('[Tracking] View tracking response:', data);\n            if (!data.success) {\n              console.warn('[Tracking] View tracking returned non-success:', data);\n            }\n          })\n          .catch(err => {\n            console.error('[Tracking] Failed to track view:', err);\n            viewTracked = false; // Allow retry on error\n          });\n        }\n\n      // Track reading time when user leaves\n      function trackReadingTime() {\n        if (!isActive) {\n          console.log('[Tracking] User inactive, skipping reading time tracking');\n          return;\n        }\n        \n        const now = Date.now();\n        const activeTime = (now - lastActiveTime) / 1000; // Convert to seconds\n        \n        if (activeTime >= MIN_READING_TIME) {\n          readingTime = Math.floor(activeTime);\n          console.log('[Tracking] Tracking reading time:', readingTime, 'seconds');\n          \n          // Use sendBeacon for more reliable tracking on page unload\n          const data = JSON.stringify({ postId, readingTime });\n          if (navigator.sendBeacon) {\n            const blob = new Blob([data], { type: 'application/json' });\n            const sent = navigator.sendBeacon('/api/track-view', blob);\n            console.log('[Tracking] Reading time sent via sendBeacon:', sent);\n          } else {\n            // Fallback to fetch\n            fetch('/api/track-view', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: data,\n              keepalive: true, // Keep request alive even after page unload\n            })\n            .then(response => {\n              console.log('[Tracking] Reading time tracked, response status:', response.status);\n              return response.json();\n            })\n            .then(data => console.log('[Tracking] Reading time tracking response:', data))\n            .catch(err => console.error('[Tracking] Failed to track reading time:', err));\n          }\n        } else {\n          console.log('[Tracking] Reading time too short:', activeTime, 'seconds, not tracking');\n        }\n      }\n\n      // Track user activity\n      function updateActivity() {\n        if (!isActive) {\n          isActive = true;\n          lastActiveTime = Date.now();\n        } else {\n          lastActiveTime = Date.now();\n        }\n      }\n\n      // Check for inactivity\n      function checkInactivity() {\n        const now = Date.now();\n        if (isActive && (now - lastActiveTime) > INACTIVE_THRESHOLD) {\n          isActive = false;\n        }\n      }\n\n      // Event listeners\n      ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event => {\n        document.addEventListener(event, updateActivity, { passive: true });\n      });\n\n      // Track initial view\n      trackView();\n\n      // Check inactivity every 10 seconds\n      setInterval(checkInactivity, 10000);\n\n      // Track reading time when user leaves\n      window.addEventListener('beforeunload', trackReadingTime);\n      window.addEventListener('pagehide', trackReadingTime);\n\n      // Also track reading time periodically (every 30 seconds) for long reads\n      setInterval(() => {\n        if (isActive) {\n          const activeTime = (Date.now() - lastActiveTime) / 1000;\n          if (activeTime >= 30) {\n            readingTime = Math.floor(activeTime);\n            console.log('[Tracking] Periodic reading time tracking:', readingTime, 'seconds');\n            fetch('/api/track-view', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({ postId, readingTime }),\n            })\n            .then(response => {\n              if (!response.ok) {\n                throw new Error(\\`HTTP error! status: \\${response.status}\\`);\n              }\n              console.log('[Tracking] Periodic reading time tracked, response status:', response.status);\n              return response.json();\n            })\n            .then(data => {\n              console.log('[Tracking] Periodic reading time response:', data);\n              if (data.success) {\n                lastActiveTime = Date.now(); // Reset to avoid double counting\n              }\n            })\n            .catch(err => console.error('[Tracking] Failed to track periodic reading time:', err));\n          }\n        }\n      }, 30000);\n      }\n      \n      // Initialize tracking\n      // For direct page loads, initialize immediately\n      // For SPA navigation, script.js will call initializeBlogTracking()\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', initTracking);\n      } else {\n        // Check if this is SPA navigation (script.js loaded)\n        setTimeout(() => {\n          if (typeof window !== 'undefined' && typeof initializeBlogTracking === 'function') {\n            // SPA navigation - let script.js handle it\n            console.log('[Tracking] SPA navigation detected, using script.js tracking');\n            // Reset flag so script.js can initialize\n            if (window.blogTrackingInitialized) {\n              window.blogTrackingInitialized = false;\n            }\n            initializeBlogTracking();\n          } else {\n            // Direct page load - use inline tracking\n            initTracking();\n          }\n        }, 100);\n      }\n    })();\n  <\/script> "])), maybeRenderHead(), renderComponent($$result2, "Header", $$Header, {}), addAttribute(post._id?.toString() || post.slug, "data-post-id"), post.title, post.coverImage && renderTemplate`<div style="margin: 24px 0; width: 100%;"> <img${addAttribute(post.coverImage, "src")}${addAttribute(post.title, "alt")} style="
                width: 100%;
                max-height: 500px;
                object-fit: cover;
                border-radius: 8px;
                border: 1px solid var(--border-color);
              "> </div>`, new Date(post.createdAt).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric"
  }), post.viewCount || 0, post.viewCount === 1 ? "view" : "views", post.readingTimes && post.readingTimes.length > 0 && renderTemplate`<span>
⏱️ ${Math.round(post.readingTimes.reduce((a, b) => a + b, 0) / post.readingTimes.length)}s average reading time
</span>`, post.tags && post.tags.length > 0 && renderTemplate`<div style="margin-top: 12px;"> ${post.tags.map((tag) => renderTemplate`<span style="
                  display: inline-block;
                  padding: 4px 12px;
                  margin-right: 8px;
                  background-color: var(--accent-color);
                  color: white;
                  border-radius: 4px;
                  font-size: 13px;
                "> ${tag} </span>`)} </div>`, unescapeHTML(post.content), renderComponent($$result2, "Footer", $$Footer, {})) })}`;
}, "/Users/s.m.ahadalichowdhury/Downloads/portfolio-website/src/pages/blog/[slug].astro", void 0);

const $$file = "/Users/s.m.ahadalichowdhury/Downloads/portfolio-website/src/pages/blog/[slug].astro";
const $$url = "/blog/[slug]";

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$slug,
  file: $$file,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

const page = () => _page;

export { page };
